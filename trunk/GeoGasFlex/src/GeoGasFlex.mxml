<?xml version="1.0" encoding="utf-8"?>
<mx:Application xmlns:fx="http://ns.adobe.com/mxml/2009" 
			   xmlns:s="library://ns.adobe.com/flex/spark" 
			   xmlns:mx="library://ns.adobe.com/flex/mx" minWidth="955" minHeight="600" xmlns:classes="classes.*" xmlns:views="classes.views.*" xmlns:controls="classes.model.it.sephiroth.controls.*">
	<fx:Declarations>
		<s:RemoteObject id="ro" destination="PostoCombustivelService" result="ro_resultHandler(event)" fault="ro_faultHandler(event)"/>
		
		<fx:XML xmlns="" id="treeSource">
			<node/>
		</fx:XML>
	</fx:Declarations>
	
	
	
	<fx:Script>
		<![CDATA[
			import classes.Constants;
			import classes.events.EventoPesquisa;
			import classes.model.Entidade;
			import classes.model.GMLParser;
			import classes.model.GeoLocation;
			import classes.model.Tesaurus;
			import classes.model.it.sephiroth.renderers.TreecheckboxItemRenderer;
			import classes.views.DetailPopUp;
			
			import com.google.maps.Color;
			import com.google.maps.InfoWindowOptions;
			import com.google.maps.LatLng;
			import com.google.maps.LatLngBounds;
			import com.google.maps.MapEvent;
			import com.google.maps.MapMouseEvent;
			import com.google.maps.MapMoveEvent;
			import com.google.maps.MapType;
			import com.google.maps.MapTypeOptions;
			import com.google.maps.controls.MapTypeControl;
			import com.google.maps.controls.NavigationControl;
			import com.google.maps.controls.NavigationControlOptions;
			import com.google.maps.controls.OverviewMapControl;
			import com.google.maps.controls.PositionControl;
			import com.google.maps.controls.ScaleControl;
			import com.google.maps.controls.ZoomControl;
			import com.google.maps.overlays.Marker;
			import com.google.maps.overlays.MarkerOptions;
			import com.google.maps.overlays.Polygon;
			import com.google.maps.overlays.Polyline;
			import com.google.maps.overlays.PolylineOptions;
			
			import flashx.textLayout.formats.Float;
			
			import mx.charts.renderers.CircleItemRenderer;
			import mx.collections.ArrayList;
			import mx.controls.Alert;
			import mx.controls.DataGrid;
			import mx.controls.Label;
			import mx.controls.dataGridClasses.DataGridColumn;
			import mx.core.FlexGlobals;
			import mx.events.ListEvent;
			import mx.events.TreeEvent;
			import mx.managers.PopUpManager;
			import mx.rpc.events.FaultEvent;
			import mx.rpc.events.ResultEvent;
			import mx.rpc.http.HTTPService;
			import mx.utils.URLUtil;
			
			import spark.components.gridClasses.GridColumn;
			import spark.effects.Scale;
			
			private var markers:ArrayList = new ArrayList();
			private var rows:ArrayList;
			private var geodesic:Polyline;
			
			private var columnGrid:DataGrid;
			private var popUp:DetailPopUp;
			
			private var workspace:String = 'geogas';
			private var baseLayer:String = 'gasstation';
			
			private var bboxFilter:String = "<BBOX>" +
				"<PropertyName>geom</PropertyName>" +
				"<gml:Box srsName=\"http://www.opengis.net/gml/srs/epsg.xml#4326\">" +
				"<gml:coordinates>"+Constants.REPLACE_VALUE+"</gml:coordinates>" +
				"</gml:Box>" +
				"</BBOX>";
			private var propBetweenFilter:String = "<PropertyIsBetween>" +
				"<PropertyName>"+Constants.REPLACE_PROP_NAME+"</PropertyName>" +
				"<LowerBoundary><Literal>"+Constants.REPLACE_MIN_VALUE+"</Literal></LowerBoundary>" +
				"<UpperBoundary><Literal>"+Constants.REPLACE_MAX_VALUE+"</Literal></UpperBoundary>" +
				"</PropertyIsBetween>";
			private var propIsLikeFilter:String = "<PropertyIsLike escapeChar=\"\\\" singleChar=\"_\" wildCard=\"%\">" +
				"<PropertyName>"+Constants.REPLACE_PROP_NAME+"</PropertyName>" +
				"<Literal>"+Constants.REPLACE_VALUE+"</Literal>" +
				"</PropertyIsLike>" 
			
			private var filtersBlank:String = "<Filter xmlns:gml=\"http://www.opengis.net/gml\" xmlns=\"http://www.opengis.net/ogc\">" +
				"<And>"+Constants.REPLACE_FILTERS+"</And>" +
				"</Filter>";
			
			private var preco:Number = 0;
			private var bandeira:String;
			private var raio:Number = 0;
			private var aplicarfiltros:Boolean = false;
			
			private function chamou(e:ListEvent):void{
				for each(var ent:Entidade in markers){
					if(ent.id == e.itemRenderer.data["id"]){
						ent.dispatchEvent(new Event(Constants.OPENPOPU_EVENT));
					}
				}
			}
			
			private function openDetailsPopup(event:Event):void{
				var popUp:DetailPopUp = new DetailPopUp();
				popUp.setVariables(event.target as Entidade,Tesaurus.getInstance());
				popUp.isPopUp = true;
				this.popUp = popUp;
				PopUpManager.addPopUp(popUp,this,true);
				PopUpManager.centerPopUp(this.popUp);
			}
			
			private function closePopUp(e:MouseEvent):void{
				PopUpManager.removePopUp(this.popUp);
			}
			
			private function init():void{
				Tesaurus.getInstance();
				if(Tesaurus.needDictionary()){
					Tesaurus.getInstance().updateDic();
				}
				Tesaurus.getInstance().ro.addEventListener(ResultEvent.RESULT,init_continue);
			}
			
			private function init_continue(e:Event):void{
				columnGrid = new DataGrid();
				columnGrid.width = mapC.width;
				columnGrid.height = mapC.height;
				columnGrid.addEventListener(ListEvent.ITEM_CLICK,chamou);
				colGridContainer.addElement(columnGrid);
				this.map.enableScrollWheelZoom();
				this.map.addControl(new MapTypeControl());
				this.map.addControl(new NavigationControl());
				this.map.addControl(new ScaleControl());
				this.map.addControl(new OverviewMapControl());
				this.map.setCenter(new LatLng(-7.224206,-35.881004), 12, MapType.NORMAL_MAP_TYPE);
				map.addEventListener(MapMouseEvent.CLICK,mapClicked);
				map.addEventListener(MapMoveEvent.MOVE_END, updateMap);
				//				search.addEventListener("submeter", realizarPesquisa);
				getLayersTree();
				//				updateMap(null);
			}
			
			private function getLayersTree():void{
				var serverUrl:String = Constants.SERVER_AD+"/geoserver/wfs?request=GetFeature&version=1.0.0&typeName="+this.workspace+":layers";
				var request:URLRequest = new URLRequest(serverUrl);
				var urlLoader:URLLoader = new URLLoader(request);
				urlLoader.addEventListener(Event.COMPLETE, resultHttpRequestLayersTree);
				urlLoader.addEventListener(ErrorEvent.ERROR, failHttpRequest);
				urlLoader.addEventListener(IOErrorEvent.IO_ERROR, failHttpRequest);
				urlLoader.load(request);
			}
			
			private function realizarPesquisa(ev:EventoPesquisa):void {
//				trace("bla");
				this.preco = ev.preco;
				this.raio = ev.raio;
				this.bandeira = ev.bandeira;
				updateMap(null);
			}
			
			private function updateMap(event:MapMoveEvent):void{
				limparMapa();
				requisitar();
				updateList();
			}
			
			private function updateList():void{
				columnGrid.data = rows;
				columnGrid.dataProvider = rows;
			}
			
			private function limparMapa():void{
//				if(columnGrid)
//					while(columnGrid.columns.length>0)
//						columnGrid.columns.pop();
				for(var i:int = 0; i<markers.length;i++){
					var marker:Entidade = markers.getItemAt(i) as Entidade;
					map.removeOverlay(marker);
				}
				markers = new ArrayList();
				rows = new ArrayList();
			}
			
			
			public function mapClicked(event:MapMouseEvent):void{
				if(search){
					var r:Number = new Number(search.raioInput.text);
					if(geodesic) map.removeOverlay(geodesic);
					if(map && search.raioCheck.selected && r>0){
						//					var circle:Polygon = new Polygon(
						//					var marker:Entidade = new Entidade(latLng,1,defaultData,otherTabs);
						var latL:LatLng = event.latLng;
						var geoLoc:GeoLocation = GeoLocation.getInstanceDegrees(latL.lat(),latL.lng());
						var coords:ArrayList = geoLoc.boundingCoordinates(r);
						
						var polyOpt:PolylineOptions = new PolylineOptions();
						polyOpt.geodesic = true;
						
						geodesic = new Polyline(coords.toArray(),polyOpt);
						
						map.addOverlay(geodesic);
						var zoom:Number = map.getBoundsZoomLevel(geodesic.getLatLngBounds());
						map.setCenter(latL,zoom);
						
					}
				}
			}
			
			public function addMarker(marker:Entidade):void{
				marker.addEventListener(MapMouseEvent.CLICK,markerClicked);
				marker.addEventListener(Constants.OPENPOPU_EVENT,openDetailsPopup);
				map.addOverlay(marker);
				markers.addItem(marker);
				putEntidadeOnList(marker);
			}
			
			public function markerClicked(event:MapEvent):void{
				var marker:Entidade = event.target as Entidade;
				marker.openInfoWindow(marker.getInfoWindowOptions());
			}
			
			protected function ro_resultHandler(event:ResultEvent):void {
				var serverUrl:String = event.result.toString();
				var request:URLRequest = new URLRequest(serverUrl);
				request.method = URLRequestMethod.POST;
				request.data;
				var urlLoader:URLLoader = new URLLoader(request);
				urlLoader.addEventListener(Event.COMPLETE, resultHttpRequest);
				urlLoader.addEventListener(ErrorEvent.ERROR, failHttpRequest);
				urlLoader.addEventListener(IOErrorEvent.IO_ERROR, failHttpRequest);
				urlLoader.load(request);
			}
			
			protected function ro_faultHandler(event:FaultEvent):void {
				Alert.show('Ocorreu um erro com o Objeto Remoto, tente novamente mais tarde.');
			}
			
			private function getMapBBox():String{
				var bbox:LatLngBounds = map.getLatLngBounds();
				var bboxStr:String = 
					'<ogc:BBOX> ' +
					'        <ogc:PropertyName>geom</ogc:PropertyName> ' +
					'        <gml:Box srsName="http://www.opengis.net/gml/srs/epsg.xml#4326"> ' +
					'           <gml:coordinates>'+ bbox.getSouthWest().lng()+","+bbox.getSouthWest().lat()+" "+bbox.getNorthEast().lng()+","+bbox.getNorthEast().lat() +'</gml:coordinates> ' +
					'        </gml:Box> ' +
					'</ogc:BBOX>';
				
				return bboxStr;
			}
			
			private function requisitar():void {
//				var serverUrl:String = Constants.SERVER_AD+"/geoserver/wfs?request=GetFeature&version=1.0.0&typeName=geogas:gasstation&FILTER=";
				var serverUrl:String = Constants.SERVER_AD+"/geoserver/wfs";
//				var filters:String = bboxFilter.replace(Constants.REPLACE_VALUE,getMapBBox());
				var filters:String = getMapBBox();
				
				var data2:XML = new XML(myTree.dataProvider);
				var layersFilter:String = '<Or>'+Constants.REPLACE_FILTERS+'</Or>';
				var layersFilterData:String = '';
				var withCleanFilter:Dictionary = new Dictionary();
				var props:ArrayList = new ArrayList();
				for each(var node:XML in data2.children()){
					var label:String = node.@label;
					for each(var childNode:XML in node.children()){
						var propName:String = childNode.@folder;
						var propLayer:String = withCleanFilter[propName];
						var newPropFilter:String = '';
						if(childNode.@islike_value != 'undefined'){
							if(propLayer == null){
								var propClean:String = propIsLikeFilter.replace(Constants.REPLACE_PROP_NAME,childNode.@prop_name);
								propClean = propClean.replace(Constants.REPLACE_VALUE,'#@!NENHUMA SELECIONADA!@#')+'\n';
								propLayer = layersFilter.replace(Constants.REPLACE_FILTERS,propClean+' '+Constants.REPLACE_FILTERS);
							}
							if(childNode.@checked == 1){
								newPropFilter += propIsLikeFilter.replace(Constants.REPLACE_PROP_NAME,childNode.@prop_name);
								newPropFilter = newPropFilter.replace(Constants.REPLACE_VALUE,'%'+childNode.@label+'%')+'\n';
							}
						}else if(childNode.@islike_value == 'undefined' && childNode.@min_value != 'undefined' && childNode.@max_value != 'undefined' ){
							if(propLayer == null){
								var prop2Clean:String = propBetweenFilter.replace(Constants.REPLACE_PROP_NAME,childNode.@prop_name);
								prop2Clean = prop2Clean.replace(Constants.REPLACE_MIN_VALUE,'-2');
								prop2Clean = prop2Clean.replace(Constants.REPLACE_MAX_VALUE,'-1')+'\n';
								
								if(childNode.@has_user_prop == 1){
									prop2Clean += propBetweenFilter.replace(Constants.REPLACE_PROP_NAME,childNode.@prop_name+'_user');
									prop2Clean = prop2Clean.replace(Constants.REPLACE_MIN_VALUE,'-2');
									prop2Clean = prop2Clean.replace(Constants.REPLACE_MAX_VALUE,'-1')+'\n';
								}
								
								propLayer = layersFilter.replace(Constants.REPLACE_FILTERS,prop2Clean+' '+Constants.REPLACE_FILTERS);
							}else if(!propLayer.indexOf(childNode.@prop_name)>=0){
								var prop3Clean:String = propBetweenFilter.replace(Constants.REPLACE_PROP_NAME,childNode.@prop_name);
								prop3Clean = prop3Clean.replace(Constants.REPLACE_MIN_VALUE,'-2');
								prop3Clean = prop3Clean.replace(Constants.REPLACE_MAX_VALUE,'-1')+'\n';
								
								if(childNode.@has_user_prop == 1){
									prop3Clean += propBetweenFilter.replace(Constants.REPLACE_PROP_NAME,childNode.@prop_name+'_user');
									prop3Clean = prop3Clean.replace(Constants.REPLACE_MIN_VALUE,'-2');
									prop3Clean = prop3Clean.replace(Constants.REPLACE_MAX_VALUE,'-1')+'\n';
								}
								propLayer = propLayer.replace(Constants.REPLACE_FILTERS,prop3Clean+ ' ' + Constants.REPLACE_FILTERS);
							}
							
//							var combFilt:String = layersFilter.replace(Constants.REPLACE_FILTERS,prop2Clean + ' ' + Constants.REPLACE_FILTERS);
							if(childNode.@checked == 1){
								newPropFilter = propBetweenFilter.replace(Constants.REPLACE_PROP_NAME,childNode.@prop_name);
								newPropFilter = newPropFilter.replace(Constants.REPLACE_MIN_VALUE,childNode.@min_value);
								newPropFilter = newPropFilter.replace(Constants.REPLACE_MAX_VALUE,childNode.@max_value)+'\n';
								if(childNode.@has_user_prop == 1){
									newPropFilter += propBetweenFilter.replace(Constants.REPLACE_PROP_NAME,childNode.@prop_name+'_user');
									newPropFilter = newPropFilter.replace(Constants.REPLACE_MIN_VALUE,childNode.@min_value);
									newPropFilter = newPropFilter.replace(Constants.REPLACE_MAX_VALUE,childNode.@max_value)+'\n';
								}
							}
//							propLayer = propLayer.replace(Constants.REPLACE_FILTERS,newPropFilter+ ' ' + Constants.REPLACE_FILTERS);
						}
						if(!hasString(props,propName)){
							props.addItem(propName);
						}
						withCleanFilter[propName] = propLayer.replace(Constants.REPLACE_FILTERS,newPropFilter+' '+Constants.REPLACE_FILTERS);
					}
				}
				
				for(var index:int = 0; index < props.length; index++){
					var propStr:String = props.getItemAt(index).toString();
					var filter:String = withCleanFilter[propStr].toString().replace(Constants.REPLACE_FILTERS, '');
					layersFilterData += filter;
				}
				filters+='<And>'+layersFilterData+'</And>';
				
				if(search && this.search.bandCheck.selected && (search.getBandeira().length>0)){
					var filbandeira:String = propIsLikeFilter.replace(Constants.REPLACE_PROP_NAME,"bandeira").replace(Constants.REPLACE_VALUE,"%"+search.getBandeira()+"%");
					filters+=filbandeira;
				}
				var xmlRequest:String = 
					'<wfs:GetFeature service="WFS" version="1.0.0" ' +
						'	outputFormat="GML2" ' +
						'	xmlns:topp="http://www.openplans.org/topp" ' +
						'	xmlns:wfs="http://www.opengis.net/wfs" ' +
						'	xmlns:ogc="http://www.opengis.net/ogc" ' +
						'	xmlns:gml="http://www.opengis.net/gml"' +
						'	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" ' +
						'	xsi:schemaLocation="http://www.opengis.net/wfs ' +
						'  		http://schemas.opengis.net/wfs/1.0.0/WFS-basic.xsd"> \n' +
						
						'	<wfs:Query typeName="'+this.workspace+':'+this.baseLayer+'"> \n' +
						'		<ogc:Filter><And>\n' + filters +
						'		</And></ogc:Filter> \n' +
						'	</wfs:Query>\n ' +
					'</wfs:GetFeature>\n'
				//ro.encodeUrl.send(serverUrl,filtersBlank.replace(Constants.REPLACE_FILTERS,filters));
				
				var service:HTTPService = new HTTPService();
				service.url = serverUrl;
				service.resultFormat = "e4x";
				service.method = "POST";
				service.contentType = "text/xml";
				service.showBusyCursor = true;
				service.addEventListener(ResultEvent.RESULT, resultHttpRequest);
				service.addEventListener(FaultEvent.FAULT, failHttpRequest);
				service.send(xmlRequest);
				
			}
			
			private function hasString(props:ArrayList,propName:String):Boolean{
				for (var i:int = 0; i<props.length;i++){
					if(props.getItemAt(i).toString().toLowerCase() == propName.toLowerCase()){
						return true;
					}
				}
				return false;
			}
			
			private function resultHttpRequestLayersTree(e:Event):void{
				var xml:XML = new XML(e.target.data);
				var parser:GMLParser = new GMLParser(xml);
				var dic:Dictionary = parser.getDictionary();
				createTree(dic);
				updateMap(null);
			}
			
			private function createTree(dic:Dictionary):void{
				var hash:Dictionary = new Dictionary();
				var folders:ArrayList = new ArrayList();
				for each(var layer:Object in dic){
					var strFolder:String = layer[Constants.PROP_LAYER_FOLDER];
					var strLayer:String = '    <node label="'+layer[Constants.PROP_LAYER_LABEL]+'" ' +
						'checked="1" prop_name="'+layer[Constants.PROP_LAYER_PROP_NAME]+'" ' +
						'islike_value="'+layer[Constants.PROP_LAYER_ISLIKE_VALUE]+'" ' +
						'min_value="'+layer[Constants.PROP_LAYER_MIN_VALUE]+'" ' +
						'max_value="'+layer[Constants.PROP_LAYER_MAX_VALUE]+'" ' +
						'has_user_prop="'+layer[Constants.PROP_HAS_USER_PROP]+'"' +
						'folder="'+strFolder+'"/> \n';
					if(hash[strFolder])
						hash[strFolder] += strLayer;
					else{
						hash[strFolder] = strLayer;
						folders.addItem(strFolder);
					}
					
				}
				//<node label="Layers" checked="1">
				var strTree:String = '';
				for(var i:int = 0; i<folders.length; i++){
					var folder:String = folders.getItemAt(i) as String;
					var node:String = '<node label="'+folder+'" checked="1">\n'+hash[folder]+'</node>\n'
					strTree += node;
				}
				treeSource = XML('<node>'+strTree+'</node>');
			}
			
			public function resultHttpRequest(e:ResultEvent):void {
				var xml:XML = new XML(e.result);
				var parser:GMLParser = new GMLParser(xml);
				var dic:Dictionary = parser.getDictionary();
				var columns:ArrayList = new ArrayList();
				for(var marker:String in dic){
					var data:Dictionary = new Dictionary();
					var lat:Number = 0;
					var lng:Number = 0;
					var id:int = 0;
					var dic2:Dictionary = dic[marker];
					for(var prop:String in dic2){
						var label:String = prop.toString().replace(this.workspace+"::","");
//						label = label.toString().replace(,"");
						if(label.toLocaleLowerCase().indexOf("price")>=0){
							label.length;
						}
						if( label.toUpperCase() == Constants.LATITUDE.toUpperCase()){
							lat = new Number( dic2[prop]);
						}
						else if( label.toUpperCase() == Constants.LONGITUDE.toUpperCase()){
							lng = new Number( dic2[prop]);
						}
						else{
							if( label.toUpperCase().indexOf(Constants.ID.toUpperCase())>=0){
								id = new Number(dic[marker][prop]);
							}else if(!(label.toUpperCase() == "GEOM")){
								data[label] = dic2[prop];
								if(!(columns.getItemIndex(label)>=0)){
									columns.addItem(label);
								}
							}
						}
					}
					var defaulData:Dictionary = new Dictionary();
					defaulData = data;
					var entidade:Entidade = new Entidade(new LatLng(lat,lng),id,defaulData);
					addMarker(entidade);
				}
				columns.source.sort();
				columnGrid.columns = getGridColumns(columns.source);
				FlexGlobals.topLevelApplication.enabled = true;
			}
			
			public function getGridColumns(columns:Array):Array{
				
				var ret:ArrayList = new ArrayList();
				for(var i:int; i<columns.length; i++){
					var gCol:DataGridColumn = new DataGridColumn();
					gCol.dataField = columns[i].toString();
					var t:String = Tesaurus.getInstance().getTraducao(columns[i].toString());
					gCol.headerText = t;
					ret.addItem(gCol);
				}
				return ret.source;
			}
			
			public function failHttpRequest(e:FaultEvent):void {
//				Alert.show('Ocorreu um erro com a comunicação, tente novamente mais tarde.');
			}
			
			public function putEntidadeOnList(marker:Entidade):void{
				var data:Dictionary = marker.data;
//				var columns:ArrayList = new ArrayList();
//				for(var editable:String in data){
//					var dic:Dictionary = data[editable];
//					for(var key:String in dic){
//						var gCol:DataGridColumn = new DataGridColumn();
//						gCol.dataField = key;
//						var t:String = Tesaurus.getInstance().getTraducao(key);
//						gCol.headerText = t;
//						columns.addItem(gCol);
//					}
//				}
				
				
//				for(var editable2:String in ){
//					var dic2:Dictionary = data[editable2];
					var obj:Object = new Object();
					for(var key2:String in data){
						obj[key2] = Tesaurus.getInstance().getTraducao(data[key2]);
					}
					obj["id"] = marker.id;
					rows.addItem(obj);
//				}
				
			}
			
			
			/**
			 * Called on checkbox click
			 * check and update for both parents and child nodes
			 * according to the checkbox status
			 */
			private function onItemCheck( event: TreeEvent ): void
			{
				FlexGlobals.topLevelApplication.enabled = false;
				updateParents( event.item as XML, ( event.itemRenderer as TreecheckboxItemRenderer ).checkBox.checkState );
				updateChilds( event.item as XML, ( event.itemRenderer as TreecheckboxItemRenderer ).checkBox.checkState );
				updateMap(null);
			}
			
			/**
			 * @see it.sephiroth.controls.CheckBoxExtended#checkState
			 * 
			 */
			private function updateChilds( item:XML, value: uint ):void
			{
				var middle: Boolean = ( value & 2 << 1 ) == ( 2 << 1 );
				var selected: Boolean = ( value & 1 << 1 ) == ( 1 << 1 );
				
				if( item.children( ).length( ) > 0 && !middle )
				{
					for each(var x: XML in item.node )
					{
						x.@checked = value == ( 1 << 1 | 2 << 1 ) ? "2" : value == ( 1 << 1 ) ? "1" : "0";
						updateChilds( x, value );
					}
				}
			}
			
			private function updateParents( item: XML, value: uint ): void
			{
				var checkValue: String = ( value == ( 1 << 1 | 2 << 1 ) ? "2" : value == ( 1 << 1 ) ? "1" : "0" );
				var parentNode: XML = item.parent( );
				if( parentNode )
				{
					for each(var x: XML in parentNode.node )
					{
						if( x.@checked != checkValue )
						{
							checkValue = "2"
						}
					}
					parentNode.@checked = checkValue;
					updateParents( parentNode, value );
				}
			}
			
		]]>
	</fx:Script>
	
	<s:HGroup width="100%" height="100%">
	<s:BorderContainer width="20%" height="100%">
		<mx:TabNavigator x="0" y="-1" width="100%" height="100%">
			<s:NavigatorContent width="100%" height="100%" label="Layers">
				<controls:TreeCheckBox id="myTree"
									   showRoot="false"
									   width="100%"
									   height="100%"
									   dataProvider="{treeSource}"
									   openItems="{treeSource..node}"
									   labelField="@label"
									   checkField="@checked"
									   itemCheck="onItemCheck( event )" editable="false">
					
				</controls:TreeCheckBox>
			</s:NavigatorContent>
			<s:NavigatorContent width="100%" height="100%" label="Search">
				<views:SearchComponent id="search" x="0" y="0" width="100%" height="100%">
				</views:SearchComponent>
			</s:NavigatorContent>
		</mx:TabNavigator>
	</s:BorderContainer>
	<mx:TabNavigator width="80%" height="100%">
		<s:NavigatorContent id="mapTab" width="100%" height="100%" label="Map">
				<s:BorderContainer width="100%" height="100%" id="mapC">
					<maps:Map xmlns:maps="com.google.maps.*" id="map" mapevent_mapready="init()" width="100%" height="100%" sensor="true"
							  key="ABQIAAAArTOg12ENOoBN3O9kedACIxRkOv5Oc89yJ4sUflDi_EcLCzRIOBTMHpzPf7PADkHpU0-4GpQuUVpflw"/>
				</s:BorderContainer>
		</s:NavigatorContent>
		<s:NavigatorContent width="100%" height="100%" label="List" id="colGridContainer">
		</s:NavigatorContent>
	</mx:TabNavigator>
	</s:HGroup>
</mx:Application>
