<?xml version="1.0" encoding="utf-8"?>
<mx:Application xmlns:fx="http://ns.adobe.com/mxml/2009" 
			   xmlns:s="library://ns.adobe.com/flex/spark" 
			   xmlns:mx="library://ns.adobe.com/flex/mx" minWidth="955" minHeight="600" xmlns:classes="classes.*" xmlns:views="classes.views.*" xmlns:controls="classes.model.it.sephiroth.controls.*">
	<fx:Declarations>
		<s:RemoteObject id="ro" destination="PostoCombustivelService" result="ro_resultHandler(event)" fault="ro_faultHandler(event)"/>
		
		<fx:XML xmlns="" id="treeSource">
			<node/>
		</fx:XML>
	</fx:Declarations>
	
	
	
	<fx:Script>
		<![CDATA[
			import classes.Constants;
			import classes.events.EventoPesquisa;
			import classes.model.Entidade;
			import classes.model.GMLParser;
			import classes.model.GeoLocation;
			import classes.model.Tesaurus;
			import classes.model.it.sephiroth.renderers.TreecheckboxItemRenderer;
			import classes.views.DetailPopUp;
			
			import com.google.maps.Color;
			import com.google.maps.InfoWindowOptions;
			import com.google.maps.LatLng;
			import com.google.maps.LatLngBounds;
			import com.google.maps.MapEvent;
			import com.google.maps.MapMouseEvent;
			import com.google.maps.MapMoveEvent;
			import com.google.maps.MapType;
			import com.google.maps.MapTypeOptions;
			import com.google.maps.controls.MapTypeControl;
			import com.google.maps.controls.NavigationControl;
			import com.google.maps.controls.NavigationControlOptions;
			import com.google.maps.controls.OverviewMapControl;
			import com.google.maps.controls.PositionControl;
			import com.google.maps.controls.ScaleControl;
			import com.google.maps.controls.ZoomControl;
			import com.google.maps.overlays.Marker;
			import com.google.maps.overlays.MarkerOptions;
			import com.google.maps.overlays.Polygon;
			import com.google.maps.overlays.Polyline;
			import com.google.maps.overlays.PolylineOptions;
			
			import flashx.textLayout.formats.Float;
			
			import mx.charts.renderers.CircleItemRenderer;
			import mx.collections.ArrayList;
			import mx.controls.Alert;
			import mx.controls.DataGrid;
			import mx.controls.Label;
			import mx.controls.dataGridClasses.DataGridColumn;
			import mx.core.FlexGlobals;
			import mx.events.ListEvent;
			import mx.events.TreeEvent;
			import mx.managers.PopUpManager;
			import mx.rpc.events.FaultEvent;
			import mx.rpc.events.ResultEvent;
			import mx.utils.URLUtil;
			
			import spark.components.gridClasses.GridColumn;
			import spark.effects.Scale;
			
			private var markers:ArrayList = new ArrayList();
			private var rows:ArrayList;
			private var geodesic:Polyline;
			
			private var columnGrid:DataGrid;
			private var popUp:DetailPopUp;
			
			private var bboxFilter:String = "<BBOX>" +
				"<PropertyName>geom</PropertyName>" +
				"<gml:Box srsName=\"http://www.opengis.net/gml/srs/epsg.xml#4326\">" +
				"<gml:coordinates>"+Constants.REPLACE_VALUE+"</gml:coordinates>" +
				"</gml:Box>" +
				"</BBOX>";
			private var propBetweenFilter:String = "<PropertyIsBetween>" +
				"<PropertyName>"+Constants.REPLACE_PROP_NAME+"</PropertyName>" +
				"<LowerBoundary><Literal>"+Constants.REPLACE_MIN_VALUE+"</Literal></LowerBoundary>" +
				"<UpperBoundary><Literal>"+Constants.REPLACE_MAX_VALUE+"</Literal></UpperBoundary>" +
				"</PropertyIsBetween>";
			private var propIsLikeFilter:String = "<PropertyIsLike escapeChar=\"\\\" singleChar=\"_\" wildCard=\"%\">" +
				"<PropertyName>"+Constants.REPLACE_PROP_NAME+"</PropertyName>" +
				"<Literal>"+Constants.REPLACE_VALUE+"</Literal>" +
				"</PropertyIsLike>" 
			
			private var filtersBlank:String = "<Filter xmlns:gml=\"http://www.opengis.net/gml\" xmlns=\"http://www.opengis.net/ogc\">" +
				"<And>"+Constants.REPLACE_FILTERS+"</And>" +
				"</Filter>";
			
			private var preco:Number = 0;
			private var bandeira:String;
			private var raio:Number = 0;
			private var aplicarfiltros:Boolean = false;
			
			private function chamou(e:ListEvent):void{
				openDetailsPopup(e.itemRenderer.data["id"],e.itemRenderer.data["type_entity"]);
			}
			
			private function openDetailsPopup(id:int, typeEntity:String):void{
				var popUp:DetailPopUp = new DetailPopUp();
				popUp.setVariables(id,typeEntity,Tesaurus.getInstance());
				popUp.isPopUp = true;
				this.popUp = popUp;
				PopUpManager.addPopUp(popUp,this,true);
				PopUpManager.centerPopUp(this.popUp);
			}
			
			private function closePopUp(e:MouseEvent):void{
				PopUpManager.removePopUp(this.popUp);
			}
			
			private function init():void{
				Tesaurus.getInstance();
				columnGrid = new DataGrid();
				columnGrid.width = mapC.width;
				columnGrid.height = mapC.height;
				columnGrid.addEventListener(ListEvent.ITEM_CLICK,chamou);
				colGridContainer.addElement(columnGrid);
				if(Tesaurus.needDictionary()){
					Tesaurus.getInstance().updateDic();
				}
				this.map.enableScrollWheelZoom();
				this.map.addControl(new MapTypeControl());
				this.map.addControl(new NavigationControl());
				this.map.addControl(new ScaleControl());
				this.map.addControl(new OverviewMapControl());
				this.map.setCenter(new LatLng(-7.224206,-35.881004), 12, MapType.NORMAL_MAP_TYPE);
				map.addEventListener(MapMouseEvent.CLICK,mapClicked);
				map.addEventListener(MapMoveEvent.MOVE_END, updateMap);
//				search.addEventListener("submeter", realizarPesquisa);
				getLayersTree();
//				updateMap(null);
			}
			
			private function getLayersTree():void{
				var serverUrl:String = "http://localhost:8080/geoserver/wfs?request=GetFeature&version=1.0.0&typeName=geogas:layers";
				var request:URLRequest = new URLRequest(serverUrl);
				var urlLoader:URLLoader = new URLLoader(request);
				urlLoader.addEventListener(Event.COMPLETE, resultHttpRequestLayersTree);
				urlLoader.addEventListener(ErrorEvent.ERROR, failHttpRequest);
				urlLoader.addEventListener(IOErrorEvent.IO_ERROR, failHttpRequest);
				urlLoader.load(request);
			}
			
			private function realizarPesquisa(ev:EventoPesquisa):void {
//				trace("bla");
				this.preco = ev.preco;
				this.raio = ev.raio;
				this.bandeira = ev.bandeira;
				updateMap(null);
			}
			
			private function updateMap(event:MapMoveEvent):void{
				limparMapa();
				requisitar();
				updateList();
			}
			
			private function updateList():void{
				columnGrid.data = rows;
				columnGrid.dataProvider = rows;
			}
			
			private function limparMapa():void{
//				if(columnGrid)
//					while(columnGrid.columns.length>0)
//						columnGrid.columns.pop();
				for(var i:int = 0; i<markers.length;i++){
					var marker:Entidade = markers.getItemAt(i) as Entidade;
					map.removeOverlay(marker);
				}
				markers = new ArrayList();
				rows = new ArrayList();
			}
			
			
			public function mapClicked(event:MapMouseEvent):void{
				if(search){
					var r:Number = new Number(search.raioInput.text);
					if(geodesic) map.removeOverlay(geodesic);
					if(map && search.raioCheck.selected && r>0){
						//					var circle:Polygon = new Polygon(
						//					var marker:Entidade = new Entidade(latLng,1,defaultData,otherTabs);
						var latL:LatLng = event.latLng;
						var geoLoc:GeoLocation = GeoLocation.getInstanceDegrees(latL.lat(),latL.lng());
						var coords:ArrayList = geoLoc.boundingCoordinates(r);
						
						var polyOpt:PolylineOptions = new PolylineOptions();
						polyOpt.geodesic = true;
						
						geodesic = new Polyline(coords.toArray(),polyOpt);
						
						map.addOverlay(geodesic);
					}
				}
			}
			
			public function addMarker(marker:Entidade):void{
				marker.addEventListener(MapMouseEvent.CLICK,markerClicked);
				map.addOverlay(marker);
				markers.addItem(marker);
				putEntidadeOnList(marker);
			}
			
			public function markerClicked(event:MapEvent):void{
				var marker:Entidade = event.target as Entidade;
				marker.openInfoWindow(marker.getInfoWindowOptions());
			}
			
			protected function ro_resultHandler(event:ResultEvent):void {
				var serverUrl:String = event.result.toString();
				var request:URLRequest = new URLRequest(serverUrl);
				var urlLoader:URLLoader = new URLLoader(request);
				urlLoader.addEventListener(Event.COMPLETE, resultHttpRequest);
				urlLoader.addEventListener(ErrorEvent.ERROR, failHttpRequest);
				urlLoader.addEventListener(IOErrorEvent.IO_ERROR, failHttpRequest);
				urlLoader.load(request);
			}
			
			protected function ro_faultHandler(event:FaultEvent):void {
				Alert.show('Ocorreu um erro com o Objeto Remoto, tente novamente mais tarde.');
			}
			
			private function getMapBBox():String{
				var bbox:LatLngBounds = map.getLatLngBounds();
				var bboxStr:String;
				bboxStr = bbox.getSouthWest().lng()+","+bbox.getSouthWest().lat()+" "+bbox.getNorthEast().lng()+","+bbox.getNorthEast().lat();
				return bboxStr;
			}
			
			private function requisitar():void {
				var serverUrl:String = "http://localhost:8080/geoserver/wfs?request=GetFeature&version=1.0.0&typeName=geogas:gasstation&FILTER=";
				var filters:String = bboxFilter.replace(Constants.REPLACE_VALUE,getMapBBox());
				
				
				var data2:XML = new XML(myTree.dataProvider);
				var layersFilter:String = '<Or>'+Constants.REPLACE_FILTERS+'</Or>';
				var layersFilterData:String = '';
				for each(var node:XML in data2.children()){
					var label:String = node.@label;
					if(label.toLowerCase() == Constants.BANDEIRA_FOLDER){
						var bandeiraClean:String = propIsLikeFilter.replace(Constants.REPLACE_PROP_NAME,'bandeira');
						bandeiraClean = bandeiraClean.replace(Constants.REPLACE_VALUE,'#@!NENHUMA SELECIONADA!@#');
						
						var bandeiraLayer:String = layersFilter.replace(Constants.REPLACE_FILTERS,bandeiraClean+' '+Constants.REPLACE_FILTERS);
						var newBandeiraFilter:String = '';
						for each(var bandeira:XML in node.children()){
							if(bandeira.@checked == 1){
								newBandeiraFilter += propIsLikeFilter.replace(Constants.REPLACE_PROP_NAME,bandeira.@prop_name);
								newBandeiraFilter = newBandeiraFilter.replace(Constants.REPLACE_VALUE,'%'+bandeira.@label+'%');
							}
						}
						layersFilterData += bandeiraLayer.replace(Constants.REPLACE_FILTERS,newBandeiraFilter);
					}else if(label.toLowerCase().indexOf(Constants.TIPO_COMBUSTIVEL_FOLDER) >=0){
						var newCombustiveisFilter:String = '';
						for each(var combustivel:XML in node.children()){
							var combustivelClean:String = propBetweenFilter.replace(Constants.REPLACE_PROP_NAME,combustivel.@prop_name);
							combustivelClean = combustivelClean.replace(Constants.REPLACE_MIN_VALUE,'-2');
							combustivelClean = combustivelClean.replace(Constants.REPLACE_MAX_VALUE,'-1');
							
							var combFilt:String = layersFilter.replace(Constants.REPLACE_FILTERS,combustivelClean + ' ' + Constants.REPLACE_FILTERS);
							var newCombFilt:String = '';
							if(combustivel.@checked == 1){
								newCombFilt = propBetweenFilter.replace(Constants.REPLACE_PROP_NAME,combustivel.@prop_name);
								newCombFilt = newCombFilt.replace(Constants.REPLACE_MIN_VALUE,'0');
								newCombFilt = newCombFilt.replace(Constants.REPLACE_MAX_VALUE,'1000');
							}
							combFilt = combFilt.replace(Constants.REPLACE_FILTERS,newCombFilt);
							newCombustiveisFilter += combFilt;
						}
						layersFilterData += layersFilter.replace(Constants.REPLACE_FILTERS,newCombustiveisFilter);
					}
				}
				
				filters+=layersFilterData;
				
				if(search && this.search.bandCheck.selected && (search.getBandeira().length>0)){
					var filbandeira:String = propIsLikeFilter.replace(Constants.REPLACE_PROP_NAME,"bandeira").replace(Constants.REPLACE_VALUE,"%"+search.getBandeira()+"%");
					filters+=filbandeira;
				}
				
				ro.encodeUrl.send(serverUrl,filtersBlank.replace(Constants.REPLACE_FILTERS,filters));
			}
			
			private function resultHttpRequestLayersTree(e:Event):void{
				var xml:XML = new XML(e.target.data);
				var parser:GMLParser = new GMLParser(xml);
				var dic:Dictionary = parser.getDictionary();
				createTree(dic);
				updateMap(null);
			}
			
			private function createTree(dic:Dictionary):void{
				var hash:Dictionary = new Dictionary();
				var folders:ArrayList = new ArrayList();
				for each(var layer:Object in dic){
					var strFolder:String = layer[Constants.PROP_LAYER_FOLDER];
					var strLayer:String = '    <node label="'+layer[Constants.PROP_LAYER_LABEL]+'" ' +
						'checked="1" prop_name="'+layer[Constants.PROP_LAYER_PROP_NAME]+'" ' +
						'islike_value="'+layer[Constants.PROP_LAYER_ISLIKE_VALUE]+'" ' +
						'min_value="'+layer[Constants.PROP_LAYER_MIN_VALUE]+'" ' +
						'max_value="'+layer[Constants.PROP_LAYER_MAX_VALUE]+'" /> \n';
					if(hash[strFolder])
						hash[strFolder] += strLayer;
					else{
						hash[strFolder] = strLayer;
						folders.addItem(strFolder);
					}
					
				}
				//<node label="Layers" checked="1">
				var strTree:String = '';
				for(var i:int = 0; i<folders.length; i++){
					var folder:String = folders.getItemAt(i) as String;
					var node:String = '<node label="'+folder+'" checked="1">\n'+hash[folder]+'</node>\n'
					strTree += node;
				}
				treeSource = XML('<node>'+strTree+'</node>');
			}
			
			public function resultHttpRequest(e:Event):void {
				var xml:XML = new XML(e.target.data);
				var parser:GMLParser = new GMLParser(xml);
				var dic:Dictionary = parser.getDictionary();
				var columns:ArrayList = new ArrayList();
				for(var marker:String in dic){
					var data:Dictionary = new Dictionary();
					var lat:Number = 0;
					var lng:Number = 0;
					var id:int = 0;
					var dic2:Dictionary = dic[marker];
					for(var prop:String in dic2){
						var label:String = prop.toString().replace("geogas","");
						label = label.toString().replace("::","");
						if(label.toLocaleLowerCase().indexOf("price")>=0){
							label.length;
						}
						if( label.toUpperCase() == Constants.LATITUDE.toUpperCase()){
							lat = new Number( dic2[prop]);
						}
						else if( label.toUpperCase() == Constants.LONGITUDE.toUpperCase()){
							lng = new Number( dic2[prop]);
						}
						else{
							if( label.toUpperCase().indexOf(Constants.ID.toUpperCase())>=0){
								id = new Number(dic[marker][prop]);
							}else if(!(label.toUpperCase() == "GEOM")){
								data[label] = dic2[prop];
								if(!(columns.getItemIndex(label)>=0)){
									columns.addItem(label);
								}
							}
						}
					}
					var defaulData:Dictionary = new Dictionary();
					defaulData["Not"+Constants.EDITABLE] = data;
					var entidade:Entidade = new Entidade(new LatLng(lat,lng),id,defaulData);
					addMarker(entidade);
				}
				columns.source.sort();
				columnGrid.columns = getGridColumns(columns.source);
				FlexGlobals.topLevelApplication.enabled = true;
			}
			
			public function getGridColumns(columns:Array):Array{
				
				var ret:ArrayList = new ArrayList();
				for(var i:int; i<columns.length; i++){
					var gCol:DataGridColumn = new DataGridColumn();
					gCol.dataField = columns[i].toString();
					var t:String = Tesaurus.getInstance().getTraducao(columns[i].toString());
					gCol.headerText = t;
					ret.addItem(gCol);
				}
				return ret.source;
			}
			
			public function failHttpRequest(e:Event):void {
//				Alert.show('Ocorreu um erro com a comunicação, tente novamente mais tarde.');
			}
			
			public function putEntidadeOnList(marker:Entidade):void{
				var data:Dictionary = marker.data;
//				var columns:ArrayList = new ArrayList();
//				for(var editable:String in data){
//					var dic:Dictionary = data[editable];
//					for(var key:String in dic){
//						var gCol:DataGridColumn = new DataGridColumn();
//						gCol.dataField = key;
//						var t:String = Tesaurus.getInstance().getTraducao(key);
//						gCol.headerText = t;
//						columns.addItem(gCol);
//					}
//				}
				
				
				for(var editable2:String in data){
					var dic2:Dictionary = data[editable2];
					var obj:Object = new Object();
					for(var key2:String in dic2){
						obj[key2] = Tesaurus.getInstance().getTraducao(dic2[key2]);
					}
					obj["id"] = marker.id;
					rows.addItem(obj);
				}
				
			}
			
			
			/**
			 * Called on checkbox click
			 * check and update for both parents and child nodes
			 * according to the checkbox status
			 */
			private function onItemCheck( event: TreeEvent ): void
			{
				FlexGlobals.topLevelApplication.enabled = false;
				updateParents( event.item as XML, ( event.itemRenderer as TreecheckboxItemRenderer ).checkBox.checkState );
				updateChilds( event.item as XML, ( event.itemRenderer as TreecheckboxItemRenderer ).checkBox.checkState );
				updateMap(null);
			}
			
			/**
			 * @see it.sephiroth.controls.CheckBoxExtended#checkState
			 * 
			 */
			private function updateChilds( item:XML, value: uint ):void
			{
				var middle: Boolean = ( value & 2 << 1 ) == ( 2 << 1 );
				var selected: Boolean = ( value & 1 << 1 ) == ( 1 << 1 );
				
				if( item.children( ).length( ) > 0 && !middle )
				{
					for each(var x: XML in item.node )
					{
						x.@checked = value == ( 1 << 1 | 2 << 1 ) ? "2" : value == ( 1 << 1 ) ? "1" : "0";
						updateChilds( x, value );
					}
				}
			}
			
			private function updateParents( item: XML, value: uint ): void
			{
				var checkValue: String = ( value == ( 1 << 1 | 2 << 1 ) ? "2" : value == ( 1 << 1 ) ? "1" : "0" );
				var parentNode: XML = item.parent( );
				if( parentNode )
				{
					for each(var x: XML in parentNode.node )
					{
						if( x.@checked != checkValue )
						{
							checkValue = "2"
						}
					}
					parentNode.@checked = checkValue;
					updateParents( parentNode, value );
				}
			}
			
		]]>
	</fx:Script>
	
	<s:HGroup width="100%" height="100%">
	<s:BorderContainer width="20%" height="100%">
		<mx:TabNavigator x="0" y="-1" width="100%" height="100%">
			<s:NavigatorContent width="100%" height="100%" label="Layers">
				<controls:TreeCheckBox id="myTree"
									   showRoot="false"
									   width="100%"
									   height="100%"
									   dataProvider="{treeSource}"
									   openItems="{treeSource..node}"
									   labelField="@label"
									   checkField="@checked"
									   itemCheck="onItemCheck( event )" editable="false">
					
				</controls:TreeCheckBox>
			</s:NavigatorContent>
			<s:NavigatorContent width="100%" height="100%" label="Search">
				<views:SearchComponent id="search" x="0" y="0" width="100%" height="100%">
				</views:SearchComponent>
			</s:NavigatorContent>
		</mx:TabNavigator>
	</s:BorderContainer>
	<mx:TabNavigator width="80%" height="100%">
		<s:NavigatorContent id="mapTab" width="100%" height="100%" label="Map">
				<s:BorderContainer width="100%" height="100%" id="mapC">
					<maps:Map xmlns:maps="com.google.maps.*" id="map" mapevent_mapready="init()" width="100%" height="100%" sensor="true"
							  key="ABQIAAAArTOg12ENOoBN3O9kedACIxRkOv5Oc89yJ4sUflDi_EcLCzRIOBTMHpzPf7PADkHpU0-4GpQuUVpflw"/>
				</s:BorderContainer>
		</s:NavigatorContent>
		<s:NavigatorContent width="100%" height="100%" label="List" id="colGridContainer">
		</s:NavigatorContent>
	</mx:TabNavigator>
	</s:HGroup>
</mx:Application>
